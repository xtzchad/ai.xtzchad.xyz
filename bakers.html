<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Staking Data</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            color: #333;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        header {
            background-color: #0F61FF;
            color: #fff;
            width: 100%;
            text-align: center;
        }

        table {
            width: 90%;
            max-width: 1200px;
            border-collapse: separate;
            border-spacing: 0;
            margin: 2em 0;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        th, td {
            padding: 1em;
            text-align: left;
            cursor: pointer;
        }

        th {
            background-color: #003EE0;
            color: #fff;
        }

        tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        tr:hover {
            background-color: #ddd;
        }

        a {
            color: #3b5998;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .center {
            text-align: center;
            margin: 1em 0;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0F61FF;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 2em auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 600px) {
            table, th, td {
                display: block;
                width: 100%;
            }

            th, td {
                padding: 0.5em;
            }

            tr {
                margin-bottom: 1em;
                display: block;
                border-bottom: 1px solid #ddd;
            }

            tr:last-child {
                border-bottom: none;
            }

            th {
                background-color: transparent;
                color: #333;
                text-transform: uppercase;
                font-weight: bold;
            }
        }
    </style>
</head>
<body>

<header>
    <h1>Staking Assistant</h1>
</header>

<div class="center">
    <a href="https://gov.tez.capital" target="_blank">Put your tezzies to work with gov.tez.capital</a>
    <a href="https://stake.tezos.com" target="_blank">or stake.tezos.com</a>
</div>

<div id="totalStakedBalance" class="center"></div>

<div id="spinner" class="spinner"></div>

<table id="delegateTable">
    <thead>
        <tr>
            <th>Address</th>
            <th>Alias</th>
            <th id="freeSpaceHeader">Free Space</th>
            <th id="feeHeader">Fee (%)</th>
        </tr>
    </thead>
    <tbody></tbody>
</table>

<script>
    async function fetchDelegateData() {
        const spinner = document.getElementById('spinner');
        const table = document.getElementById('delegateTable');
        const totalStakedBalanceDiv = document.getElementById('totalStakedBalance');

        spinner.style.display = 'block';
        table.style.display = 'none';

        try {
            let bakers = await fetch('https://api.tzkt.io/v1/delegates?limit=10000&active=true');
            let data = await bakers.json();
            let stats = await fetch('https://api.tzkt.io/v1/statistics/current');
            let staked = await stats.json();

            let delegateData = [];

            data.forEach(delegate => {
                if (delegate.limitOfStakingOverBaking && delegate.limitOfStakingOverBaking > 0) {
                    let address = delegate.address;
                    let alias = delegate.alias || 'No alias';
                    let balance = ((delegate.stakedBalance * delegate.limitOfStakingOverBaking / 1000000 - delegate.externalStakedBalance) / 1000000).toFixed(6);
                    let edgeOfBakingOverStaking = (delegate.edgeOfBakingOverStaking / 10000000).toFixed(2);

                    delegateData.push({
                        address: address,
                        alias: alias,
                        balance: parseInt(balance),
                        edgeOfBakingOverStaking: edgeOfBakingOverStaking + "%"
                    });
                }
            });

            // Display total staked balance
            totalStakedBalanceDiv.textContent = 'Total Staked Balance: ' + parseInt(staked.totalFrozen / 1000000).toLocaleString() + ' tez (' + (staked.totalFrozen / staked.totalSupply * 100).toFixed(2) + '%).'+'Track it on <a href="https://up.xtzchad.xyz" target="_blank">up.xtzchad.xyz</a>';

            // Sort the data by balance in descending order
            delegateData.sort((a, b) => b.balance - a.balance);

            // Move the specific address to the top
            let specialAddressIndex = delegateData.findIndex(delegate => delegate.address === "tz1aJHKKUWrwfsuoftdmwNBbBctjSWchMWZY");
            if (specialAddressIndex !== -1) {
                let [specialDelegate] = delegateData.splice(specialAddressIndex, 1);
                delegateData.unshift(specialDelegate);
            }

            // Clear the table body
            const tableBody = table.querySelector('tbody');
            tableBody.innerHTML = '';

            // Populate the table with sorted data
            delegateData.forEach(delegate => {
                let row = tableBody.insertRow();
                let cell1 = row.insertCell(0);
                let cell2 = row.insertCell(1);
                let cell3 = row.insertCell(2);
                let cell4 = row.insertCell(3);

                cell1.textContent = delegate.address;
                cell2.textContent = delegate.alias;
                cell3.textContent = delegate.balance;
                cell4.textContent = delegate.edgeOfBakingOverStaking;
            });

        } catch (error) {
            console.error('Error fetching data:', error);
        } finally {
            spinner.style.display = 'none';
            table.style.display = 'table';
        }
    }

    // Sort table by column index
    function sortTable(columnIndex, isNumeric) {
        const table = document.getElementById('delegateTable');
        const tbody = table.querySelector('tbody');
        const rows = Array.from(tbody.rows);

        const compare = (a, b) => {
            const cellA = a.cells[columnIndex].textContent;
            const cellB = b.cells[columnIndex].textContent;
            return isNumeric ? parseFloat(cellA) - parseFloat(cellB) : cellA.localeCompare(cellB);
        };

        const currentOrder = table.getAttribute('data-sort-order') || 'asc';
        const newOrder = currentOrder === 'asc' ? 'desc' : 'asc';

        rows.sort((a, b) => (newOrder === 'asc' ? compare(a, b) : compare(b, a)));

        tbody.append(...rows);
        table.setAttribute('data-sort-order', newOrder);
    }

    // Add click event listeners to headers
    document.getElementById('freeSpaceHeader').addEventListener('click', () => sortTable(2, true));
    document.getElementById('feeHeader').addEventListener('click', () => sortTable(3, true));

    // Fetch data initially and then every 60 seconds
    fetchDelegateData();
    setInterval(fetchDelegateData, 60000);
</script>

</body>
</html>
