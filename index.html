<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CHAD AI Simulator</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/chartjs-plugin-dragdata@latest/dist/chartjs-plugin-dragdata.min.js"></script>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/3.0.1/chartjs-plugin-annotation.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css"
    integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
  <style>
    @import url(https://fonts.googleapis.com/css?family=Roboto:400,100,300,500,700,900);

    label {
      margin-bottom: 0 !important;
    }

    .roboto {
      font-family: "Roboto";
    }

    body {
      margin: auto;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      overflow: auto;
      background: linear-gradient(315deg, rgba(15, 97, 255, 1) 3%, rgba(159, 50, 159, 1) 38%, rgba(15, 97, 255, 1) 68%, rgba(159, 50, 159, 1) 98%);
      animation: gradient 15s ease infinite;
      background-size: 400% 400%;
      background-attachment: fixed;
    }

    @keyframes gradient {
      0% {
        background-position: 0% 0%;
      }

      50% {
        background-position: 100% 100%;
      }

      100% {
        background-position: 0% 0%;
      }
    }

    .wave {}

    .wave:nth-of-type(2) {
      bottom: -1.25em;
      animation: wave 18s linear reverse infinite;
      opacity: 0.8;
    }

    .wave:nth-of-type(3) {
      bottom: -2.5em;
      animation: wave 20s -1s reverse infinite;
      opacity: 0.9;
    }

    @keyframes wave {
      2% {
        transform: translateX(1);
      }

      25% {
        transform: translateX(-25%);
      }

      50% {
        transform: translateX(-50%);
      }

      75% {
        transform: translateX(-25%);
      }

      100% {
        transform: translateX(1);
      }
    }

    @keyframes AnimationName {
      0% {
        background-position: 50% 0%;
      }

      50% {
        background-position: 51% 100%;
      }

      100% {
        background-position: 50% 0%;
      }
    }

    .shaky {
      animation: shake 0.5s infinite alternate;
    }

    @keyframes shake {
      0% {
        transform: translateX(0);
      }

      25% {
        transform: translateX(-5px);
      }

      50% {
        transform: translateX(5px);
      }

      75% {
        transform: translateX(-3px);
      }

      100% {
        transform: translateX(3px);
      }
    }


    :where(html) {
      --darkmode: 0;
      container-name: root;
      container-type: normal;
    }

    body {
      --background-color: #FFF;
      --text-color: #fff;
      background-color: var(--background-color);
      color: var(--text-color);
      color-scheme: light dark;
      font-family: ui-sans-serif, system-ui, sans-serif;
    }

    @media (prefers-color-scheme: dark) {
      html {
        --darkmode: 1;
      }
    }

    @media (prefers-color-scheme: light) {
      html {
        --darkmode: 0;
      }
    }

    html:has(#color-scheme-light:checked) {
      --darkmode: 0;
    }

    html:has(#color-scheme-dark:checked) {
      --darkmode: 1;
    }

    @container root style(--darkmode: 0) {
      body {
        --background-color: hsl(228, 5%, 15%);
      }
    }

    .toggle-group {
      border: 2px solid #CCC;
      border-radius: 24px;
      inline-size: fit-content;
      padding: 3px;
      margin-top: 5px;
    }

    .toggle-group label {
      border-radius: 21px;
      cursor: pointer;
      display: inline-flex;
      padding: 0.5em 1em;
      text-align: center;
      user-select: none;
    }

    .toggle-group label:has(input:checked) {
      background-color: #CCC;
      color: #333;
    }

    [data-sr] {
      clip: rect(0 0 0 0);
      clip-path: inset(50%);
      height: 1px;
      overflow: hidden;
      position: absolute;
      white-space: nowrap;
      width: 1px;
    }

    .bar {
      background: #333;
      background: #1d2e38;
      background: -moz-linear-gradient(left, #1d2e38 0%, #2b4254 50%, #2b4254 100%);
      background: -webkit-gradient(linear, left top, right top, color-stop(0%, #1d2e38), color-stop(50%, #2b4254), color-stop(100%, #2b4254));
      background: -webkit-linear-gradient(left, #1d2e38 0%, #2b4254 50%, #2b4254 100%);
      background: -o-linear-gradient(left, #1d2e38 0%, #2b4254 50%, #2b4254 100%);
      background: -ms-linear-gradient(left, #1d2e38 0%, #2b4254 50%, #2b4254 100%);
      background: linear-gradient(left, #1d2e38 0%, #2b4254 50%, #2b4254 100%);
      filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#1d2e38', endColorstr='#2b4254', GradientType=1);

      -webkit-border-radius: 40px;
      -moz-border-radius: 40px;
      border-radius: 40px;
    }
  </style>
</head>

<body>
  <div class="wave" style="position:absolute;"></div>
  <div class="container-fluid">
    <!--<div class="row justify-content-md-center text-center">
      <h1 class="shake-me roboto" id="titlesim">Simulate me harder baby!</h1>
    </div>
    <div class="row mx-auto mx-md-0 text-center justify-content-md-center"><input class="mx-auto mx-md-0" type="range"
        id="range" min="0" max="1" value="0.067" step="0.001"
        oninput="rangeO.value = range.value;issuance.data.datasets[2].data=Array.from({length: 100}, (_, i) => issuanceRate(i+1,this.value));issuance.update();stake.data.datasets[0].data=Array.from({length: 100}, (_, i) => this.value);stake.update();location.hash=btoa(Array.from({length: 100}, (_, i) => this.value).toString());" />
    </div>
    <div class="row justify-content-md-center text-center"><output class="mx-auto mx-md-0 roboto"
        id="rangeO">0.067</output>
    </div>-->
    <div class="row h-50">

      <div class="col-lg-6" style="margin-bottom:10px">
        <canvas style="border-radius:20px;" id="stake"></canvas>
      </div>

      <div class="col-lg-6" style="margin-bottom:10px">
        <canvas id="issuance" style="border-radius:20px;"></canvas>
      </div>

    </div>
  </div>

  <script>
   /* const rangeInput = document.getElementById("range");
    const h1Element = document.querySelector(".shake-me");

    rangeInput.addEventListener("input", function () {
      // Calculate animation duration based on input value
      const animationDuration = this.value > 0.5 ? 0.25 : 0.5;

      // Remove prev animation and set new animation duration
      h1Element.style.animation = "none";
      h1Element.style.animation = `shake ${animationDuration}s infinite alternate`;

      // Add or remove shaky class based on input value
      if (this.value > 0.067) {
        if (this.value > 0.5) {
          h1Element.innerHTML = "Ooh, you are so good at this!";
          h1Element.classList.add("shaky");
        }
        else
          h1Element.innerHTML = "Simulate me harder baby!";
      } else {
        h1Element.innerHTML = "Simulate me harder baby!";
        h1Element.classList.remove("shaky");
        h1Element.style = "";
      }
    });*/
    const transition_period = 50;
    const initial_period = 10;
    const ai_activation_cycle = 1;

    //This calculates min and max issuance values depending on cycle and upper/lower limits
    function computeExtremum(cycle, initial_value, final_value) {

      const trans = transition_period + 1;
      const initial_limit = ai_activation_cycle + initial_period;
      const trans_limit = initial_limit + trans;

      if (cycle <= initial_limit) {
        return initial_value;
      } else if (cycle >= trans_limit) {
        return final_value;
      } else {
        const t = cycle - initial_limit;
        const res = (t * (final_value - initial_value) / trans) + initial_value;
        return res;
      }
    }

    function minimumRatio(cycle) {
      return computeExtremum(cycle, 0.045, 0.0025);
    }

    function maximumRatio(cycle) {
      return computeExtremum(cycle, 0.055, 0.1);
    }

    function stakedRatio(cycle, value) {
      return value;
    }

    function staticRate(cycle, value) {
      const stakedRatioValue = value;
      const staticRateValue = 1 / 1600 * (1 / (stakedRatioValue ** 2));
      return clip(staticRateValue, minimumRatio(cycle + 1), maximumRatio(cycle + 1));
    }

    function clip(value, min_value, max_value) {
      return Math.max(min_value, Math.min(value, max_value));
    }

    var tmp = 0;
    //calculate bonus reward
    function dyn(cycle, value, tmp1) {
      if (cycle <= ai_activation_cycle) {
        tmp = 0;
        return 0;
      }
      const previousBonus = tmp;
      const stakedRatioValue = tmp1;
      const secondsPerCycle = 245760;
      const ratioMax = maximumRatio(cycle + 1);
      const staticRateValue = staticRate(cycle, value);
      const staticRateDistToMax = ratioMax - staticRateValue;
      const udist = Math.max(0, Math.abs(stakedRatioValue - 0.5) - 0.02);
      const dist = stakedRatioValue >= 0.5 ? -udist : udist;
      const daysPerCycle = secondsPerCycle / 86400;
      const maxNewBonus = Math.min(staticRateDistToMax, 0.05);
      newBonus = previousBonus + dist * 0.01 * daysPerCycle;
      const res = clip(newBonus, 0, maxNewBonus);
      console.assert(res >= 0 && res <= 5);
      tmp = res;
      return res;
    }
    var tmp1;
    //calculate total reward - static + bonus, make sure it's in [min,max] ratiorange
    function issuanceRate(cycle, value) {
      const adjustedCycle = cycle;
      tmp1 = value;
      const staticRateRatio = staticRate(cycle, value);
      const bonus = dyn(cycle, value, tmp1);
      const ratioMin = minimumRatio(adjustedCycle);
      const ratioMax = maximumRatio(adjustedCycle);
      const totalRate = staticRateRatio + bonus;
      return clip(totalRate, ratioMin, ratioMax) * 100;
    }


  </script>
  <script>
var stx = document.getElementById('stake').getContext("2d");
var gradientStroke = stx.createLinearGradient(500, 0, 100, 0);
gradientStroke.addColorStop(0, '#80b6f4');
gradientStroke.addColorStop(1, '#f49080');

var itx = document.getElementById('issuance').getContext("2d");
var gradientStroke = stx.createLinearGradient(500, 0, 100, 0);
gradientStroke.addColorStop(0, '#80b6f4');
gradientStroke.addColorStop(1, '#f49080');
    // Setup charts
    if (location.hash != "") {
      ratio = atob(location.hash.substring(1)).split(",");
    }
    else
      ratio = Array.from({length: 100}, (_, i) => 0.067);
    //ratio = 0.067;
    dataIssuance = {
      labels: Array.from({length: 100}, (_, i) => i + 1),
      datasets: [{
        label: 'MaxRatio',
        data: Array.from({length: 100}, (_, i) => maximumRatio(i + 1) * 100),
        backgroundColor: 'rgba(255, 99, 132, 0.2)',
        borderColor: 'rgba(255, 99, 132, 1)',
        borderWidth: 3,
        pointRadius: 1,
      }, {
        label: 'MinRatio',
        data: Array.from({length: 100}, (_, i) => minimumRatio(i + 1) * 100),
        backgroundColor: 'rgba(255, 99, 132, 0.2)',
        borderColor: 'rgba(255, 99, 132, 1)',
        borderWidth: 3,
        pointRadius: 1,
      },
      {
        label: 'Issuance',
        data: Array.from({length: 100}, (_, i) => issuanceRate(i + 1, ratio[i])),
borderColor: gradientStroke,
            pointBorderColor: gradientStroke,
            pointBackgroundColor: gradientStroke,
           pointHoverBackgroundColor: gradientStroke,
            pointHoverBorderColor: gradientStroke,
backgroundColor: 'rgba(1, 255, 132, 0.2)',

        borderWidth: 3,
        pointRadius: 1,
      }]
    };
    dataStake = {
      labels: Array.from({length: 100}, (_, i) => i + 1),
      datasets: [{
borderColor: gradientStroke,
            pointBorderColor: gradientStroke,
            pointBackgroundColor: gradientStroke,
           pointHoverBackgroundColor: gradientStroke,
            pointHoverBorderColor: gradientStroke,
        label: 'Stake (Drag points to customize)',
        data: Array.from({length: 100}, (_, i) => stakedRatio(i + 1, ratio[i])),
        backgroundColor: 'rgba(255, 99, 132, 0.2)',
        borderWidth: 3,
        pointRadius: 1,
      }]
    };

    // Configuration
    configIssuance = {
      type: 'line',
      data: dataIssuance,
      options: {
        plugins: {
          tooltip: {
            enabled: true,
          }
        },
        scales: {
          x: {
            title: {
              display: true,
              text: 'Cycles'
            },
            ticks: {
              stepSize: 1
            }
          },
          y: {
            title: {
              display: true,
              text: 'Issuance'
            },
            min: 0,
            max: 11,
            ticks: {
              stepSize: 1
            }
          }
        }
      }
    };
    configStake = {
      type: 'line',
      data: dataStake,
      options: {
        elements: {
          line: {
            tension: 0.4
          }
        },
        //parsing: false,
        plugins: {
          tooltip: {
            enabled: true
          },
          annotation: {
            annotations: [{
              type: 'box',
              drawTime: 'beforeDatasetsDraw',
              yMin: 0.48,
              yMax: 0.52,
              backgroundColor: 'rgba(255, 255, 0, 0.1)'
            }]
          },
          dragData: {
            round: 3, // rounds the values to n decimal places
            showTooltip: true, // show the tooltip while dragging [default = true]
            onDragStart: function (e, element) {
            },
            onDrag: function (e, datasetIndex, index, value) {
              tmp = value;
              for (i = index; i < window.stake.data.datasets[datasetIndex].data.length; i++) {window.stake.data.datasets[datasetIndex].data[i] = value}
              window.stake.update();
              issuance.data.datasets[2].data = Array.from({length: 100}, (_, i) => issuanceRate(i + 1, window.stake.data.datasets[0].data[i]));
              location.hash = btoa(window.stake.data.datasets[datasetIndex].data.toString());
              issuance.update();
            },
            onDragEnd: function (e, datasetIndex, index, value) {

            },
          },
        },
        scales: {
          x: {
            title: {
              display: true,
              text: 'Cycles'
            },
            ticks: {
              stepSize: 1
            }
          },
          y: {
            title: {
              display: true,
              text: 'Staking Ratio'
            },
            min: 0,
            max: 1,
            ticks: {
              stepSize: 0.2
            }
          }
        }
      }
    };
    // Create the chart
    var issuance = new Chart(
      itx,
      configIssuance
    );

    var stake = new Chart(
      stx,
      configStake
    );
    document.getElementById('issuance').style['background-color'] = '#fff';
    document.getElementById('stake').style['background-color'] = '#fff';
  </script>
  <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
    integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
    crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
    integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
    crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/js/bootstrap.min.js"
    integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
    crossorigin="anonymous"></script>
</body>

</html>
